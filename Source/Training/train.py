'''''
--- Trains the neural network.
-- 
-- Uses data generated by @{data_generation_call}.
-- @module train
'''''
import sys

sys.path.insert(0, '../Settings')
sys.path.insert(0, '../Game')
sys.path.insert(0, '../Nn')
import optim
import arguments
import masked_huber_loss
import torch
M = {}

'''
--- Saves a neural net model to disk.
-- 
-- The model is saved to `arguments.model_path` and labelled with the epoch
-- number.
-- @param model the neural net to save
-- @param epoch the current epoch number
-- @param valid_loss the validation loss of the current network
-- @local
'''


class model(object):
    def _save_model(self,model, epoch, valid_loss):

        model_information = {}
        model_information.epoch = epoch
        model_information.valid_loss = valid_loss
        model_information.gpu = arguments.gpu

        net_type_str = arguments.gpu and '_gpu' or '_cpu'
        model_file_name = arguments.model_path + '/epoch_' + epoch + net_type_str + '.model'
        information_file_name = arguments.model_path + '/epoch_' + epoch + net_type_str + '.info'
        torch.save(model_file_name, model)
        torch.save(information_file_name, model_information)

    '''
    --- Function passed to torch's [optim package](https.//github.com/torch/optim).
    -- @param params_new the neural network params
    -- @param inputs the neural network inputs
    -- @param targets the neural network targets
    -- @param mask the mask vectors used for the loss function
    -- @return the masked Huber loss on `inputs` and `targets` 
    -- @return the gradient of the loss function
    -- @see masked_huber_loss
    -- @local
    '''

    def feval(self,params_new, inputs, targets, mask):
        # -- set x to x_new, if different
        # -- (in this simple implementation, x_new will typically always point to x,
        # -- so the copy is really useless)
        if M.params != params_new:
            M.params.copy(params_new)

        M.grads.zero()
        outputs = M.network.forward(inputs)
        loss = M.criterion.forward(outputs, targets, mask)

        ##-- backward
        dloss_doutput = M.criterion.backward(outputs, targets)
        M.network.backward(inputs, dloss_doutput)
        return loss, M.grads

    '''
    --- Trains the neural network.
    -- @param network the neural network (see @{net_builder})
    -- @param data_stream a @{data_stream|DataStream} object which provides the
    -- training data
    -- @param epoch_count the number of epochs (passes of the training data) to train for
    '''

    def train(self,network, data_stream, epoch_count):

        M.network = network
        M.data_stream = data_stream

        M.params, M.grads = network.getParameters()
        M.criterion = MaskedHuberLoss()
        if (arguments.gpu):
            M.criterion = M.criterion.cuda()

        state = {learningRate = arguments.learning_rate}
        lossSum = 0
        optim_func = optim.adam

        ##-- optimization loop
        timer = torch.Timer()
        for epoch = 1, epoch_count do
        timer.reset()
        data_stream.start_epoch(epoch)
        lossSum = 0

        for i in range(1, data_stream.get_train_batch_count()):
            inputs, targets, mask = data_stream.get_train_batch(i)
            assert (mask)
            _, loss = optim_func((x)
            return feval(x, inputs, targets, mask)
            end, M.params, state)
            lossSum = lossSum + loss[1]

            print(string.format("Training loss. %f", lossSum / data_stream.train_batch_count))

            ##--check validation loss
            valid_loss_sum = 0
            for i in range(1, data_stream.get_valid_batch_count()):
                inputs, targets, mask = data_stream.get_valid_batch(i)
            assert (mask)
            outputs = M.network.forward(inputs)
            loss = M.criterion.forward(outputs, targets, mask)
            valid_loss_sum = valid_loss_sum + loss

            valid_loss = valid_loss_sum / data_stream.valid_batch_count
            print(string.format("Validation loss. %f", valid_loss))
            print('Epoch took. ', timer.time().real)

            ##--saving the model
            print(epoch)
            if epoch % arguments.save_epoch == 0:
                print("SAVING MODEL")
                self._save_model(network, epoch, valid_loss)
            ##--end of train loop
            # return M
